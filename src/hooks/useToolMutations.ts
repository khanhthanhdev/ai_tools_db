/**
 * Tool Mutations Hooks with Cache Invalidation
 * 
 * This module provides React hooks for tool mutations (add, update, delete)
 * with automatic cache invalidation to keep the UI in sync.
 * 
 * All mutations use TanStack Query's useMutation with Convex integration
 * and automatically invalidate relevant queries after successful operations.
 */

import { useQueryClient } from '@tanstack/react-query';
import { api } from '../../convex/_generated/api';
import { useConvexMutation } from './useConvexMutation';
import { invalidateQueries } from '../lib/cacheInvalidation';
import { Id } from '../../convex/_generated/dataModel';

/**
 * Hook for adding a new tool
 * 
 * Implements optimistic updates by immediately adding the tool to relevant caches
 * before the server confirms, then invalidates queries to ensure consistency.
 * 
 * Automatically invalidates:
 * - Tools lists (browse page)
 * - Search results
 * - User's submitted tools
 * - Statistics
 * - Categories list
 * 
 * @example
 * ```tsx
 * const addTool = useAddTool();
 * 
 * const handleSubmit = async (data) => {
 *   try {
 *     const result = await addTool.mutateAsync(data);
 *     toast.success(result.message);
 *   } catch (error) {
 *     toast.error(error.message);
 *   }
 * };
 * ```
 */
export function useAddTool() {
  const queryClient = useQueryClient();
  
  return useConvexMutation(api.aiTools.addTool, {
    onMutate: async (variables) => {
      // Cancel any outgoing refetches to prevent race conditions
      await queryClient.cancelQueries({ queryKey: ['aiTools.listToolsPaginated', 'infinite'] });
      await queryClient.cancelQueries({ queryKey: ['aiTools.searchToolsPaginated', 'infinite'] });
      
      // Snapshot the previous values for rollback
      const previousToolsLists = queryClient.getQueriesData({ 
        queryKey: ['aiTools.listToolsPaginated', 'infinite'] 
      });
      const previousSearchResults = queryClient.getQueriesData({ 
        queryKey: ['aiTools.searchToolsPaginated', 'infinite'] 
      });
      
      // Create optimistic tool object
      const optimisticTool = {
        _id: `temp-${Date.now()}` as Id<'aiTools'>, // Temporary ID
        _creationTime: Date.now(),
        name: variables.name,
        description: variables.description,
        url: variables.url,
        category: variables.category,
        tags: variables.tags || [],
        pricing: variables.pricing,
        logoUrl: variables.logoUrl,
        language: variables.language,
        isApproved: true,
        submittedBy: 'current-user', // Will be replaced by server
        submittedAt: Date.now(),
        averageRating: 0,
        reviewCount: 0,
        favouriteCount: 0,
        viewCount: 0,
        clickCount: 0,
        // Embedding will be generated by server
      };
      
      // Optimistically update tools lists (infinite queries)
      queryClient.setQueriesData(
        { queryKey: ['aiTools.listToolsPaginated', 'infinite'] },
        (oldData: any) => {
          if (!oldData?.pages) return oldData;
          
          // Add the new tool to the first page
          const newPages = [...oldData.pages];
          if (newPages[0]?.page) {
            newPages[0] = {
              ...newPages[0],
              page: [optimisticTool, ...newPages[0].page],
            };
          }
          
          return {
            ...oldData,
            pages: newPages,
          };
        }
      );
      
      return { previousToolsLists, previousSearchResults, optimisticTool };
    },
    
    onError: (error, variables, context) => {
      // Rollback optimistic updates on error
      if (context?.previousToolsLists) {
        context.previousToolsLists.forEach(([queryKey, data]) => {
          queryClient.setQueryData(queryKey, data);
        });
      }
      if (context?.previousSearchResults) {
        context.previousSearchResults.forEach(([queryKey, data]) => {
          queryClient.setQueryData(queryKey, data);
        });
      }
    },
    
    onSuccess: (data, variables, context) => {
      // Replace optimistic tool with real data from server
      if (context?.optimisticTool && data.toolId) {
        queryClient.setQueriesData(
          { queryKey: ['aiTools.listToolsPaginated', 'infinite'] },
          (oldData: any) => {
            if (!oldData?.pages) return oldData;
            
            const newPages = oldData.pages.map((page: any) => {
              if (!page?.page) return page;
              
              return {
                ...page,
                page: page.page.map((tool: any) => 
                  tool._id === context.optimisticTool._id 
                    ? { ...tool, _id: data.toolId } // Update with real ID
                    : tool
                ),
              };
            });
            
            return {
              ...oldData,
              pages: newPages,
            };
          }
        );
      }
      
      // Invalidate all tools-related queries to ensure consistency
      invalidateQueries.toolsLists(queryClient);
      invalidateQueries.toolsSearches(queryClient);
      invalidateQueries.userTools(queryClient);
      invalidateQueries.stats(queryClient);
      invalidateQueries.categories(queryClient);
    },
  });
}

/**
 * Hook for updating an existing tool
 * 
 * Automatically invalidates:
 * - Tools lists (browse page)
 * - Search results
 * - Specific tool detail
 * - Similar tools for the updated tool
 * - User's submitted tools
 * - Statistics
 * - Categories list (in case category changed)
 * 
 * @example
 * ```tsx
 * const updateTool = useUpdateTool();
 * 
 * const handleUpdate = async (toolId, data) => {
 *   try {
 *     const result = await updateTool.mutateAsync({ toolId, ...data });
 *     toast.success(result.message);
 *   } catch (error) {
 *     toast.error(error.message);
 *   }
 * };
 * ```
 */
export function useUpdateTool() {
  const queryClient = useQueryClient();
  
  return useConvexMutation(api.aiTools.updateTool, {
    onSuccess: (data, variables) => {
      // Invalidate the specific tool detail
      invalidateQueries.toolDetail(queryClient, variables.toolId);
      
      // Invalidate similar tools since embeddings might have changed
      invalidateQueries.similarTools(queryClient, variables.toolId);
      
      // Invalidate all tools lists and searches
      invalidateQueries.toolsLists(queryClient);
      invalidateQueries.toolsSearches(queryClient);
      
      // Invalidate user's tools list
      invalidateQueries.userTools(queryClient);
      
      // Invalidate stats (in case pricing changed)
      invalidateQueries.stats(queryClient);
      
      // Invalidate categories (in case category changed)
      invalidateQueries.categories(queryClient);
    },
  });
}

/**
 * Hook for deleting a tool
 * 
 * Automatically invalidates:
 * - Tools lists (browse page)
 * - Search results
 * - User's submitted tools
 * - Statistics
 * - Categories list
 * - Removes the tool detail from cache
 * 
 * Also invalidates related data:
 * - Favourites (if tool was favourited)
 * - Reviews for the deleted tool
 * 
 * @example
 * ```tsx
 * const deleteTool = useDeleteTool();
 * 
 * const handleDelete = async (toolId) => {
 *   if (confirm('Are you sure you want to delete this tool?')) {
 *     try {
 *       const result = await deleteTool.mutateAsync({ toolId });
 *       toast.success(result.message);
 *     } catch (error) {
 *       toast.error(error.message);
 *     }
 *   }
 * };
 * ```
 */
export function useDeleteTool() {
  const queryClient = useQueryClient();
  
  return useConvexMutation(api.aiTools.deleteTool, {
    onSuccess: (data, variables) => {
      // Remove the specific tool from cache
      queryClient.removeQueries({
        queryKey: ['aiTools.getToolById', { toolId: variables.toolId }]
      });
      
      // Invalidate all tools lists and searches
      invalidateQueries.toolsLists(queryClient);
      invalidateQueries.toolsSearches(queryClient);
      
      // Invalidate user's tools list
      invalidateQueries.userTools(queryClient);
      
      // Invalidate stats
      invalidateQueries.stats(queryClient);
      
      // Invalidate categories (in case this was the last tool in a category)
      invalidateQueries.categories(queryClient);
      
      // Invalidate favourites (in case tool was favourited)
      invalidateQueries.allFavourites(queryClient);
      
      // Invalidate reviews for this tool
      invalidateQueries.toolReviews(queryClient, variables.toolId);
    },
  });
}

/**
 * Combined hook that returns all tool mutation hooks
 * Useful when you need multiple mutations in one component
 * 
 * @example
 * ```tsx
 * const { addTool, updateTool, deleteTool } = useToolMutations();
 * 
 * // Use any of the mutations
 * await addTool.mutateAsync(newToolData);
 * await updateTool.mutateAsync({ toolId, ...updates });
 * await deleteTool.mutateAsync({ toolId });
 * ```
 */
export function useToolMutations() {
  return {
    addTool: useAddTool(),
    updateTool: useUpdateTool(),
    deleteTool: useDeleteTool(),
  };
}
